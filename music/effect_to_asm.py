#!/usr/bin/env python3
import argparse
import json
import sys
import os.path
from collections import OrderedDict

class EffectToAsm(object):

    def __init__(self, channels):
        self.effects = OrderedDict()
        self.regmap = []

    def load(self, fn):
        data = []
        with open(fn) as f:
            for line in f:
                if '//' in line:
                    line = line.split('//')[0] + '\n'
                data.append(line)
        return json.loads(''.join(data))

    def convert(self, fn):
        data = self.load(fn)

        name = os.path.basename(fn)
        name, _ = name.split('.', 1)
        if name in self.effects:
            raise Exception('Effect already exists', name)

        APU_REG_LEN = 22
        apu_prev = [-1] * APU_REG_LEN
        apu_regs = [-1] * APU_REG_LEN
        effect = []

        frame_nr = 0
        phase_reset = False
        all_reset = False
        ignore = []
        for frame in data:
            if phase_reset:
                apu_regs[3] = -1
                apu_regs[7] = -1
                apu_regs[11] = -1
            if all_reset:
                apu_regs = [-1] * APU_REG_LEN
            apu_prev = apu_regs[:]
            newregs = []
            write = False
            for (k, v) in frame.items():
                if k == 'frame':
                    frame_nr = v
                    continue
                if k == 'all_reset':
                    all_reset = v
                    continue
                if k == 'phase_reset':
                    phase_reset = v
                    continue
                if k == 'ignore':
                    ignore = v
                    continue
                if k == 'zp_write':
                    addr, val = v
                    newregs.extend([0x01, addr, val])
                    write = True
                    continue
                if k == 'stop_music':
                    newregs.extend([0x02])
                    write = True
                    continue
                reg = int(k)
                if reg in ignore:
                    continue
                if reg in (0,4,12) and v & 0x20:
                    print('Warning: effect {} clears length counter in reg {}'.format(name, reg), file=sys.stderr)
                if reg in (8,) and v & 0x80:
                    print('Warning: effect {} clears length counter in reg {}'.format(name, reg), file=sys.stderr)
                apu_regs[reg] = v

            for i in range(0, APU_REG_LEN):
                if apu_prev[i] != apu_regs[i]:
                    newregs.append(0x40 + i)
                    newregs.append(apu_regs[i])
                    write = True
            
            # If any registers were changed in this frame, append a delay count
            # of one, else "increment" the prior delay count.
            if write:
                if frame_nr:
                    effect[-1] = last_frame-frame_nr
                    if effect[-1] == -1:
                        # TODO: opportunity for a more efficient encoding
                        # if the delay is one frame, set a bit in the previous
                        # command opcode indicating last opcode this frame.
                        pass
                last_frame = frame_nr
                effect.extend(newregs)
                effect.append(-1)
            #else:
            #    effect[-1] -= 1
        # Terminate the effect with a zero byte.
        effect.append(0)
        self.effects[name] = effect

    def save_asm(self, f):
        print('; Generated by effect_to_asm.py', file=f)
        print('.export _sound_effects', file=f)
        print('_sound_effects:', file=f)
        for name, effect in self.effects.items():
            if len(effect) > 1:
                print('    .word @{}'.format(name), file=f)
            else:
                print('    .word $0000', file=f)
        print('', file=f)
        print('', file=f)

        total_bytes = 0
        for name, effect in self.effects.items():
            if len(effect) == 1:
                continue
            total_bytes += len(effect)
            print('@{}: ; ({} bytes)'.format(name, len(effect)), file=f, end='')
            for i, byte in enumerate(effect):
                byte &= 0xFF
                if i%16 == 0:
                    print('\n    .byte ${:02x}'.format(byte), file=f, end='')
                else:
                    print(',${:02x}'.format(byte), file=f, end='')
            print('', file=f)
        print('', file=f)
        print('; end ({} bytes)'.format(total_bytes), file=f)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Convert effect json files to cc65-style assembly.')
    parser.add_argument('-c', '--channels', default=7, type=int)
    parser.add_argument('-o', '--output', default='-')
    parser.add_argument('files', metavar='FILE', type=str, nargs='*')
    args = parser.parse_args()
    e = EffectToAsm(args.channels)

    for f in args.files:
        e.convert(f)

    if args.output != '-':
        with open(args.output, 'wt') as f:
            e.save_asm(f)
    else:
        e.save_asm(sys.stdout)
